/*
 * Satellite_SetpointHandler.c
 *
 * Copyright (C) 2020 Martin Lundh
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
//#define DEBUG

#include "FreeRTOS.h"
#include "task.h"
#include <stdio.h>
#include "Components/AppLog/inc/AppLog.h"
#include "SetpointHandler/inc/setpoint_handler.h"
#include "Parameters/inc/paramHandler.h"
#include "SpectrumToStateHandler/inc/Satellite_SetpointHandler.h"
#include "SpectrumSatellite/inc/satellite_receiver_public.h"
#include "EventHandler/inc/event_handler.h"
#include "Messages/inc/Msg_FlightMode.h"
#include "Messages/inc/Msg_CtrlMode.h"
#include "Messages/inc/Msg_FlightModeReq.h"
#include "Messages/inc/Msg_CtrlModeReq.h"
#include "Messages/inc/Msg_NewSetpoint.h"
#include "Messages/inc/Msg_SpectrumData.h"
#include "Utilities/inc/my_math.h"


#define MESSAGE_VALID_FOR_MS (50) // A setpoint generated by this module is valid for 50ms.
/**
 * Resolution of receiver:
 * 4pi Rad/s/(2^(11)) = 0,0061359
 *
 * Resolution for state vector rate:
 * pi rad/(2^(16)) = 0.0000479368997 rad/s resolution.
 *
 * (receiver resolution)/(state resolution) = 128
 *
 * This is the quote used to scale between receiver
 * and state. The state uses a 16.16 fixed point,
 * converting the quote to this format:
 * (int32_t)128 * 65536 + 0.5 = 8388608
 * This leads to the following define:
 *
 */
#define SPECTRUM_TO_STATE_RATE (8388608)

/**
 * Resolution of receiver:
 * 2pi Rad/(2^(11)) = 0,00306796
 *
 * Resolution for state vector rate:
 * pi rad/(2^(16)) = 0.0000479368997 rad resolution.
 *
 * (receiver resolution)/(state resolution) = 64
 *
 * This is the quote used to scale between receiver
 * and state. The state uses a 16.16 fixed point,
 * converting the quote to this format:
 * (int32_t)128 * 65536 + 0.5 = 4194304
 * This leads to the following define:
 *
 */
#define SPECTRUM_TO_STATE_ANGLE (4194304)

/**
 * max receiver thrust: 100% = 7FF
 *
 * max control signal:    100% = 1<<16 = 65536
 *
 * (max control signal)/(max receiver thrust) = 32
 *
 * This is the quote used to scale between receiver
 * and state for throttle.
 * This leads to the following define:
 */
#define SPECTRUM_TO_CTRL_THROTTLE (32)



/**
 * The receiver can update the FC internal state (change to dissarmed etc.).
 * @param obj               The instance object.
 * @param merged_data       The valid and complete frames.
 * @return
 */
uint8_t SatSpHandler_UpdateState(spectrumSpHandler_t* obj, spektrum_data_t *merged_data);

/**
 * @brief Send a request to update the control mode of the system.
 * 
 * @param obj           spectrum setpoint handler object.
 * @param merged_data   Spectrum data.
 * @return uint8_t      1 if successful, 0 otherwise.
 */
uint8_t SatSpHandler_UpdateControlMode(spectrumSpHandler_t* obj, spektrum_data_t *merged_data);

/**
 * @brief Callback for flight mode change.
 */
uint8_t SatSpHandler_FModeCB(eventHandler_t* obj, void* data, moduleMsg_t* eData);

/**
 * @brief Callback for control mode change.
 */
uint8_t SatSpHandler_CtrlModeCB(eventHandler_t* obj, void* data, moduleMsg_t* eData);

/**
 * @brief Callback for new spectrum satellite data. 
 */
uint8_t SatSpHandler_HandleSatFrame(eventHandler_t* obj, void* data, moduleMsg_t* msg);


spectrumSpHandler_t* SatSpHandler_CreateObj(eventHandler_t* evHandler, param_obj_t * param)
{
    spectrumSpHandler_t *obj = pvPortMalloc( sizeof(spectrumSpHandler_t) );

    if(!obj || !evHandler)
    {
        return NULL;
    }
    obj->evHandler = evHandler;
    obj->multiplier = INT_TO_FIXED(1, FP_16_16_SHIFT);
    obj->throMult = INT_TO_FIXED(1, FP_16_16_SHIFT);
    obj->currentSetpoint = pvPortMalloc(sizeof(state_data_t));
    obj->current_flight_mode_state = fmode_not_available;
    obj->current_control_mode = Control_mode_not_available;
    param_obj_t* paramObj = Param_CreateObj(2, variable_type_NoType, readOnly, NULL, "SpectrumHandler", param);

    Event_RegisterCallback(obj->evHandler, Msg_SpectrumData_e, SatSpHandler_HandleSatFrame, obj);
    Event_RegisterCallback(obj->evHandler, Msg_FlightMode_e, SatSpHandler_FModeCB, obj);
    Event_RegisterCallback(obj->evHandler, Msg_CtrlMode_e, SatSpHandler_CtrlModeCB, obj);

    // Enable receiver sensitivity adjustment.
    Param_CreateObj(0, variable_type_fp_16_16, readWrite, &obj->multiplier, "mult", paramObj);
    Param_CreateObj(0, variable_type_fp_16_16, readWrite, &obj->throMult, "ThrottleMult", paramObj);
    return obj;
}

void SatSpHandler_DeleteObj(spectrumSpHandler_t* obj)
{
  if(obj)
  {
    vPortFree(obj);
  }
}

void SatSpHandler_MapToSetpoint(spectrumSpHandler_t* obj, spektrum_data_t *reciever_data, state_data_t *setpoint)
{
    //subtract center point and convert to State scale.

    setpoint->state_bf[thrust_sp]              = (my_mult(my_mult((reciever_data->ch[0].value), SPECTRUM_TO_CTRL_THROTTLE, 0), obj->throMult, FP_16_16_SHIFT)); // THRO
    setpoint->state_bf[yaw_rate_bf]            = (my_mult(my_mult((reciever_data->ch[3].value - SATELLITE_CH_CENTER), SPECTRUM_TO_STATE_RATE, FP_16_16_SHIFT), obj->multiplier, FP_16_16_SHIFT)); // YAW
    setpoint->state_bf[pitch_rate_bf]          = (my_mult(my_mult((reciever_data->ch[2].value - SATELLITE_CH_CENTER), SPECTRUM_TO_STATE_RATE, FP_16_16_SHIFT), obj->multiplier, FP_16_16_SHIFT)); // PITCH
    setpoint->state_bf[roll_rate_bf]           = (my_mult(my_mult((reciever_data->ch[1].value - SATELLITE_CH_CENTER), SPECTRUM_TO_STATE_RATE, FP_16_16_SHIFT), obj->multiplier, FP_16_16_SHIFT)); // ROLL

    setpoint->state_bf[pitch_bf]          = (my_mult(my_mult((reciever_data->ch[2].value - SATELLITE_CH_CENTER), SPECTRUM_TO_STATE_ANGLE, FP_16_16_SHIFT), obj->multiplier, FP_16_16_SHIFT)); // PITCH
    setpoint->state_bf[roll_bf]           = (my_mult(my_mult((reciever_data->ch[1].value - SATELLITE_CH_CENTER), SPECTRUM_TO_STATE_ANGLE, FP_16_16_SHIFT), obj->multiplier, FP_16_16_SHIFT)); // ROLL

    return;
}

uint8_t SatSpHandler_UpdateState(spectrumSpHandler_t* obj, spektrum_data_t *merged_data)
{
    if(obj->current_flight_mode_state == fmode_init || obj->current_flight_mode_state == fmode_not_available)
    {
        return 0; // Dont do anyting during init or fault condition.
    }
    /*Disarm requested*/
    uint8_t ret = 1;
    if ((merged_data->ch[4].value > SATELLITE_CH_CENTER) // Flap is on
            && (merged_data->ch[0].value < 40)) // throttle is low
    {
        if(obj->current_flight_mode_state == fmode_fault)
        {
            moduleMsg_t* msg = Msg_FlightModeReqCreate(FC_Broadcast_e, 0, fmode_exitFault);
            Event_Send(obj->evHandler, msg);
            // latch to avoid multiple events. Will get updated to real system state in event CB.
            obj->current_flight_mode_state = fmode_exitFault;
        }
        else if(obj->current_flight_mode_state != fmode_disarming && obj->current_flight_mode_state != fmode_disarmed)
        {
            moduleMsg_t* msg = Msg_FlightModeReqCreate(FC_Broadcast_e, 0, fmode_disarming);
            Event_Send(obj->evHandler, msg);
            // latch to avoid multiple events. Will get updated to real system state in event CB.
            obj->current_flight_mode_state = fmode_disarming;
        }
    }
    /*Arming request*/
    else if ((merged_data->ch[4].value < SATELLITE_CH_CENTER) // Flap is off
            && (merged_data->ch[0].value < 40)) // throttle is low
    {
        if(obj->current_flight_mode_state != fmode_arming && obj->current_flight_mode_state != fmode_armed)
        {
            moduleMsg_t* msg = Msg_FlightModeReqCreate(FC_Broadcast_e, 0, fmode_arming);
            Event_Send(obj->evHandler, msg);
            // latch to avoid multiple events. Will get updated to real system state in event CB.
            obj->current_flight_mode_state = fmode_arming;

        }
    }
    return ret;
}

uint8_t SatSpHandler_UpdateControlMode(spectrumSpHandler_t* obj, spektrum_data_t *merged_data)
{
    if(obj->current_flight_mode_state == fmode_init || obj->current_flight_mode_state == fmode_not_available)
    {
        return 0; // Dont do anyting during init or fault condition.
    }
    /*Change to attitude mode requested.*/
    uint8_t ret = 1;
    if ((merged_data->ch[5].value > SATELLITE_CH_CENTER) // gear is on
            && (merged_data->ch[0].value < 40)) // throttle is low
    {
        if(obj->current_control_mode != Control_mode_attitude)
        {
            moduleMsg_t* msg = Msg_CtrlModeReqCreate(FC_Broadcast_e, 0, Control_mode_attitude);
            Event_Send(obj->evHandler, msg);
            // latch to avoid multiple events. Will get updated to real system state in event CB.
            obj->current_control_mode = Control_mode_attitude;
        }
    }
    /*Change to rate mode requested.*/
    else if ((merged_data->ch[5].value < SATELLITE_CH_CENTER) // gear is off
            && (merged_data->ch[0].value < 40)) // throttle is low
    {
        if(obj->current_control_mode != Control_mode_rate)
        {
            moduleMsg_t* msg = Msg_CtrlModeReqCreate(FC_Broadcast_e, 0, Control_mode_rate);
            Event_Send(obj->evHandler, msg);
            // latch to avoid multiple events. Will get updated to real system state in event CB.
            obj->current_control_mode = Control_mode_rate;
        }
    }
    return ret;
}

uint8_t SatSpHandler_FModeCB(eventHandler_t* obj, void* data, moduleMsg_t* eData)
{
    if(!obj || !data || !eData)
    {
        return 0;
    }
    spectrumSpHandler_t* satellite = (spectrumSpHandler_t*)data; // data should always be the current handler.
    satellite->current_flight_mode_state =  Msg_FlightModeGetMode(eData);
    return 1;
}

uint8_t SatSpHandler_CtrlModeCB(eventHandler_t* obj, void* data, moduleMsg_t* eData)
{
    if(!obj || !data || !eData)
    {
        return 0;
    }
    spectrumSpHandler_t* satellite = (spectrumSpHandler_t*)data; // data should always be the current handler.
    satellite->current_control_mode = Msg_CtrlModeGetMode(eData);
    return 1;
}


uint8_t SatSpHandler_HandleSatFrame(eventHandler_t* obj, void* data, moduleMsg_t* msg)
{
    if(!obj || !data || !msg)
    {
        return 0;
    }
    spectrumSpHandler_t* setpointHobj = (spectrumSpHandler_t*)data; // data should always be the current handler.

    TickType_t ticks = xTaskGetTickCount();
    TickType_t ticksSinceLast = ticks - setpointHobj->timeAtLastNewSp;
    // We get new setpoints every 11 or 22 ms from a spectrum satellite, if two messages arrive
    // too closely, it is because of multiple receivers. Disregard one of them.
    if(ticksSinceLast <= 1)
    {
        LOG_DBG_ENTRY( setpointHobj->evHandler, "Dropping an SP.");
        return 1;
    }
    LOG_DBG_ENTRY( setpointHobj->evHandler, "New SP.");

    setpointHobj->timeAtLastNewSp = ticks;
    spektrum_data_t spectrumData = Msg_SpectrumDataGetData(msg);
    SatSpHandler_MapToSetpoint(setpointHobj, &spectrumData, setpointHobj->currentSetpoint);
    moduleMsg_t* msgSp = Msg_NewSetpointCreate(FC_Broadcast_e, 0, *setpointHobj->currentSetpoint, 1, MESSAGE_VALID_FOR_MS);
    Event_Send(setpointHobj->evHandler, msgSp);
    SatSpHandler_UpdateState(setpointHobj, &spectrumData);
    SatSpHandler_UpdateControlMode(setpointHobj, &spectrumData);

    return 1;
}
